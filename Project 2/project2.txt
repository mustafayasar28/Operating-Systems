/* Mustafa Yasar CS-342 Operating Systems Project 2 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <pthread.h>
#include <math.h>
#include <stdbool.h>

double My_random(unsigned seed);

/* The node that the threads will add to the runqueue */
struct runqueue_elem {
	struct runqueue_elem *next;
	/* data here */
	bool done;
	int thread_index;
	int burst_index;
	double length;	/* in ms */
	/* wall clock time */
};

/* The queue (linked list) that the threads will add the runqueue_elems into */
struct runqueue {
	struct runqueue_elem *head;
	struct runqueue_elem *tail;
	int count; /* Number of runqueue elements in the queue */
};

/* Constructor of the runqueue */
void runqueue_init(struct runqueue *rq) {
	rq->count = 0;
	rq->head = NULL;
	rq->tail = NULL;
}

/* Runqueue insertion, adds the element to the tail of the queue */
void runqueue_insert(struct runqueue *q, struct runqueue_elem *qe) {
	if (q -> count == 0) {
		q->head = qe;
		q->tail = qe;
	} else {
		q->tail->next = qe;
		q->tail = qe;
	}

	q->count++;
}

/* Delete a specific burst node from the runqueue */
void runqueue_remove(struct runqueue *rq, struct runqueue_elem *qe) {
    if ( rq->count == 0 ) return;

    if ( rq->count == 1 ) {
        rq -> head = NULL;
        rq -> tail = NULL;
        rq -> count--;
        free(qe);
        return;
    }

    if ( qe == rq -> head ) {
        rq -> head = qe -> next;
        free(qe);
        rq -> count--;
        return;
    }

    struct runqueue_elem *previous = rq -> head;

    while ( previous -> next != qe ) {
        previous = previous -> next;
    }

    if ( qe == rq -> tail ) {
        rq -> tail = previous;
        rq -> tail -> next = NULL;
        rq -> count--;
        free(qe);
        return;
    }

    previous -> next = qe -> next;
    free(qe);
    rq -> count--;
}

/* Runqueue retrieval, retrieves the head node and deletes it from the queue */
struct runqueue_elem * runqueue_retrieve(struct runqueue *rq) {
	struct runqueue_elem *qe;

	if ( rq->count == 0 ) return NULL;

	qe = rq->head;

	rq->head = rq->head->next;
	rq->count--;

	return qe;
}

/* The object that is shared by the threads */
struct shared_buffer {
	struct runqueue *rq;
	pthread_mutex_t mutex_queue;	/* mutex to ensure synchronization among threads */
	pthread_cond_t	cond_hasburst;	/* will cause the S Thread to wait */
};

struct shared_buffer *buf;
char algorithm[15];
int total_burst_count;
int Bcount;

void shared_buffer_add(struct shared_buffer *sbp, struct runqueue_elem *elem) {
    pthread_mutex_lock( &(sbp -> mutex_queue) );

    /* Critical section, put the burst into the queue */
    printf("Thread index:%d is in critical section\n", elem->thread_index);

    runqueue_insert(sbp->rq, elem);

    if (sbp->rq->count > 0) {
        pthread_cond_signal(&(sbp->cond_hasburst));
    }

    printf("Thread index:%d EXITTED the critical section\n", elem->thread_index);
    pthread_mutex_unlock( &(sbp->mutex_queue) );
}

struct thread_args {
	int i;		/* Thread index */
	int avgB;
	int avgA;
	int Bcount;
	int minA;
	int minB;
};

struct s_thread_args {
    char alg[15];
};

static void * generate_burst(void * _arg) {
	/* Generate a sequence of cpu bursts one by by
		and add them to rq.

		Length of each burst is random.

		avgA >= 100 and avgB >= 100

		f(x) = lambda * exp(-lambda * x).

		Here, the lambda is the rate parameter. It is 1/avgA (for interarrival times).
		It is 1/avgB (for burst times)

		We will generate a random number between 0 and 1 UNTIL the generated
		random number is greater than minA / 1000 (For inter-arrival time and sleeping time)

		We will generate a random number between 0 and 1 UNTIL the generated
		random number is greater than minB / 1000 (For Burst time)

	*/

	struct thread_args *th_args = (struct thread_args *) _arg;

	int index = th_args -> i + 1;
	int avgB = th_args -> avgB;
	int avgA = th_args -> avgA;
	int Bcount = th_args -> Bcount;
	int minA = th_args -> minA;
	int minB = th_args -> minB;

    My_random(index); /* Different seeds for different threads */
	double lambda = (double) 1 / (double) avgA;
	double rand_num = (double) rand() / (double) RAND_MAX;
	double arrival_sleep_time = (double) -1/lambda * log(1 - rand_num);

	while (arrival_sleep_time < minA) {
		rand_num = (double) rand() / (double) RAND_MAX;
		arrival_sleep_time = (double) -1/lambda * log(1 - rand_num);
	}

	/* arrival_sleep_time is in ms */
	usleep( arrival_sleep_time * 1000 ); /* Convert mikroseconds to milliseconds */


    for (int i = 0; i < Bcount; i++) {
        double b_lambda = (double) 1 / (double) avgB;
        double b_rand_num = (double) rand() / (double) RAND_MAX;
        double burst_length = (double) -1/b_lambda * log(1 - b_rand_num);

        while (burst_length < minB) {
            b_rand_num = (double) rand() / (double) RAND_MAX;
            burst_length = (double) -1/b_lambda * log(1 - b_rand_num);
        }

        struct runqueue_elem *burst;
        /*	buf = (struct shared_buffer *) malloc(sizeof(struct shared_buffer));*/
        burst = (struct runqueue_elem *) malloc(sizeof(struct runqueue_elem));

        burst->thread_index = index;
        burst->burst_index = i + 1;
        burst->length = burst_length;
        burst->next = NULL;
        burst->done = false;

        /* Try adding the burst into the runqueue */
        shared_buffer_add(buf, burst);

        /* */
        printf("Thread index:%d, has added burst #%d, length=%f\n", index, i + 1, burst->length);

        /* Sleep again before creating the other burst */
        double after_burst = (double) 1 / (double) avgA;
        double after_burst_rand_num = (double) rand() / (double) RAND_MAX;
        double after_burst_sleeping_time = (double) -1 / after_burst * log(1 - after_burst_rand_num);

        while(after_burst_sleeping_time < minA) {
            after_burst_rand_num = (double) rand() / (double) RAND_MAX;
            after_burst_sleeping_time = (double) -1 / after_burst * log(1 - after_burst_rand_num);
        }

        usleep(after_burst_sleeping_time * 1000);
    }

	free(th_args);
	pthread_exit(NULL);
}


static void * s_thread_func(void * arg) {
    printf("S-THREAD Created.\n");

    pthread_mutex_lock(&(buf->mutex_queue));
    printf("S Thread is waiting for an item to be added to the runqueue\n");
    while ( buf->rq->count == 0 ) {
        pthread_cond_wait( &(buf -> cond_hasburst), &(buf->mutex_queue) );
    } /* S Thread sleeps as long as the runqueue is empty */

    pthread_mutex_unlock(&(buf->mutex_queue));
    printf("An item is added to the runqueue, S Thread is awaken\n");

    int executed_burst_count = 0;

    if (strcmp(algorithm, "FCFS") == 0) {
        do {
            pthread_mutex_lock(&(buf->mutex_queue));
            while (buf -> rq -> count == 0 ) {
                pthread_cond_wait( &(buf -> cond_hasburst), &(buf -> mutex_queue));
            }

            struct runqueue_elem *elem = runqueue_retrieve(buf -> rq);

            pthread_mutex_unlock(&(buf->mutex_queue));

            printf("S Thread is executing the burst of thread #%d. It will sleep for %f ms\n", elem->thread_index, elem->length);

            usleep( elem -> length * 1000);

            printf("S Thread has executed the burst of thread #%d.\n", elem -> thread_index);

            executed_burst_count++;
            free(elem);
        } while(executed_burst_count < total_burst_count );
    } else if (strcmp(algorithm, "SJF") == 0) {

        /* First, determine which burst has the smallest burst length, */
        /* Select the burst having shortest burst_length whose burst_index is i
            i will be 1...Bcount
        */

        struct runqueue_elem *copy;
        struct runqueue_elem *next_burst;

        int i = 1;

        while(true) {
            /* Lock the queue, so that while searching for a burst to execute,
            there will be no adding to the queue. */

            pthread_mutex_lock(&(buf->mutex_queue));
            while(buf -> rq -> count == 0) {
                pthread_cond_wait(&(buf->cond_hasburst), &(buf->mutex_queue));
            }

            copy = buf -> rq -> head;
            next_burst = copy;
            double shortest = copy -> length;

            while( copy != NULL ) {
                if ( (copy -> thread_index != next_burst -> thread_index) ) {
                    if ((copy -> length < shortest)) {
                        next_burst = copy;
                        shortest = next_burst -> length;
                    }
                }
                copy = copy -> next;
            }

            printf("\nNext burst info: thid: %d, bid: %d\n", next_burst ->thread_index, next_burst->burst_index);

            pthread_mutex_unlock(&(buf -> mutex_queue));

            /* Burst having shortest length has been found found, executing. */
            printf("S Thread is executing Thread index:%d , Burst index:%d, Length:%f\n", next_burst->thread_index,
                                    next_burst->burst_index, next_burst->length);

            usleep( next_burst -> length * 1000);

            printf("S Thread has executed Thread index:%d , Burst index:%d, Length:%f\n", next_burst->thread_index,
                                    next_burst->burst_index, next_burst->length);


            runqueue_remove(buf -> rq, next_burst);
            executed_burst_count++;
            if ( executed_burst_count == total_burst_count ) break;
            if ( executed_burst_count == Bcount ) i++;
        }
    }
    pthread_exit(NULL);
}

int main(int argc, char* argv[]) {

	if ( argc != 8 && argc != 5 ) {
		printf("usage: schedule <N><Bcount><minB><avgB><minA><avgA><ALG>\n");
		printf("or\n");
		printf("usage: schedule <N><ALG> -f <inprefix>-i.txt\n");
		exit(1);
	}

	int N = atoi(argv[1]);
	/*
	if (!(N >= 1 && N <= 10)) {
		printf("N must be between 1 and 10\n");
		exit(1);
	}




	if ( minB < 100 ) {
		printf("minB can not be smaller than 100ms\n");
		exit(1);
	}




	if ( minA < 100 ) {
		printf("minA can not be smaller than 100ms\n");
		exit(1);
	}


	char ALG[10];

	strcpy(ALG, argv[7]);

	The <ALG> parameter specifies the scheduling algorithm to use. It
can be one of: “FCFS”, “SJF”, “PRIO”, “VRUNTIME”. All simulated scheduling
algorithms are non-preemptive.
	*/

	/* TODO: Add input validation to algorithm */
		int avgA = atoi(argv[6]);
		int avgB = atoi(argv[4]);
		int minB = atoi(argv[3]);
		int minA = atoi(argv[5]);
        strcpy(algorithm, argv[7]);
		Bcount = atoi(argv[2]);
        total_burst_count = N * Bcount;

        if (    (strcmp(algorithm, "PRIO") != 0) &&
                (strcmp(algorithm, "FCFS") != 0) &&
                (strcmp(algorithm, "SJF") != 0)  &&
                (strcmp(algorithm, "VRUNTIME") != 0) )
        {
            printf("Algorithm must be one of the 'PRIO', 'FCFS', 'SJF', 'VRUNTIME' ");
            exit(1);
        }


	/* Construct the buffer and runqueue */
	buf = (struct shared_buffer *) malloc(sizeof(struct shared_buffer));
	buf -> rq = (struct runqueue *) malloc(sizeof(struct runqueue));

	/* Initializations */
	runqueue_init(buf -> rq);
	pthread_mutex_init(&buf -> mutex_queue, NULL);
	pthread_cond_init(&buf -> cond_hasburst, NULL);

	pthread_t w_thread_pids[N];
	pthread_t s_thread_id;
	int ret;
	int i;


    printf("Creating S_thread.\n");
	ret = pthread_create(&s_thread_id, NULL, s_thread_func, (void *) NULL);
	if (ret < 0) {
		perror("s_thread could not be created\n");
		exit(1);
	}

	/* Create the W threads */
	for (i = 0; i < N; ++i) {
		printf("Creating W_thread_%d.\n", i + 1);

		/* Adjust thread parameters */
        struct thread_args *th_args = calloc( sizeof(struct thread_args), 1);

		th_args -> avgB = avgB;
		th_args -> avgA = avgA;
		th_args -> Bcount = Bcount;
		th_args -> i = i;
		th_args -> minA = minA;
		th_args -> minB = minB;

		ret = pthread_create(&w_thread_pids[i], NULL, generate_burst, th_args);

		if (ret < 0) {
			perror("thread could not be created\n");
			exit(1);
		}
	}



	/* Wait for the W_threads to terminate */
	for (i = 0; i < N; ++i)  {
		pthread_join(w_thread_pids[i], NULL);
	}

	pthread_join(s_thread_id, NULL);	/* Wait for the S_thread to terminate */



	printf("\n\nProgram Finished. Runqueue information \n\n");

	while( buf->rq->count > 0 ) {
        printf("Queue element %d, length=%f, thread_index=%d \n", i, buf->rq->head->length, buf->rq->head->thread_index);
        struct runqueue_elem *elem = runqueue_retrieve(buf->rq);
        free(elem);
	}

	free(buf -> rq);
	free(buf);

	return 0;
}


double My_random(unsigned seed) {
	static unsigned z;
	unsigned long tmp;

	if (seed != 0) z = seed;

	tmp = z * 279470273;
	z = tmp % 4294967291U;
	return z;
}

























